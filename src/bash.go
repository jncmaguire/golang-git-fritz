package main

import (
	"fmt"
)

const bashHeader string = `#!/bin/bash
#
# Generated by https://gitlab.com/jncmaguire/golang-git-fritz
# This is a %s hook
`

// bashArg contains the variable name and the descriptive comment for an argument.
type bashArg struct {
	name    string
	comment string
}

// script contains all the information needed to build a script for a githook.
type script struct {
	name        string
	arguments   []bashArg
	prompts     map[string]string
	features    map[string]string
	canFail     bool
	exampleFail string
}

var (
	prepareCommitMsgHookScript = script{
		name: hookPrepareCommitMsg,
		arguments: []bashArg{
			bashArg{"commit_file", "location of temp file for commit"},
			bashArg{"commit_source", "git command that triggered hook"},
			bashArg{"commit_hash", "hash for the commit"},
		},
		prompts: map[string]string{
			"Pass commit-prep arguments": "commit_prep_arguments",
		},
		features: map[string]string{
			"Prepare commit message based on user prompts": "fritz commit-prep location=$commit_file $commit_prep_arguments",
		},
		canFail:     true,
		exampleFail: "bad inputs",
	}

	commitMsgHookScript = script{
		name: hookCommitMsg,
		arguments: []bashArg{
			bashArg{"commit_file", "location of temp file for commit"},
		},
		features: map[string]string{
			"Validate commit message": "fritz commit-validate location=$commit_file",
		},
		canFail:     true,
		exampleFail: "invalid commit",
	}
)

// scriptByHook maps hooks to script objects.
var scriptByHook = map[string]script{
	hookPrepareCommitMsg: prepareCommitMsgHookScript,
	hookCommitMsg:        commitMsgHookScript,
}

// build creates the script text for a githook, complete with comments.
func (s *script) build() (file string) {
	file += fmt.Sprintf(bashHeader, s.name)

	// if the hook is passed arguments, put them into variables in the script
	if len(s.arguments) > 0 {
		file += fmt.Sprintf("\n# Arguments passed to the hook by design")

		for i := range s.arguments {
			file += fmt.Sprintf("\n$%s=$%d # %s", s.arguments[i].name, i, s.arguments[i].comment)
		}
	}

	// if there are prompts for user input, for each prompt, print a message to the user and read the input into a variable
	if len(s.prompts) > 0 {
		file += fmt.Sprintf("\n# Prompt for more arguments")
		for prompt, varName := range s.prompts {
			file += fmt.Sprintf("\necho %s\nread %s", prompt, varName)
		}
	}

	// if anything is happening in the hook (ex. commit-prep), call the appropriate features
	if len(s.features) > 0 {
		for comment, command := range s.features {
			file += fmt.Sprintf("\n# %s\n%s", comment, command)
		}
	}

	// if the hook can fail (cancelling the action), note it in the script
	if s.canFail {
		file += fmt.Sprintf("\n# A non-zero return (ex. %s) will prevent the hook trigger from advancing", s.exampleFail)
	}

	return file
}
